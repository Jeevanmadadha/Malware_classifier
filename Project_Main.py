import os
from PIL import Image
import torch
import torch.nn as nn
import torch.nn.functional as Func
from torchvision.transforms import Compose, Resize, ToTensor, RandomHorizontalFlip, RandomRotation
from torch.utils.data import Dataset, DataLoader
import timm
import io
import streamlit as st


# Define the dataset class
class MyDataset(Dataset):
    def __init__(self, root_dir, transform=None):
        self.root_dir = root_dir
        self.transform = transform
        self.image_paths = []

        for subdir, dirs, files in os.walk(self.root_dir):
            for file in files:
                image_path = os.path.join(subdir, file)
                self.image_paths.append(image_path)

        self.image_paths = list(set(self.image_paths))  # Remove duplicates

    def __len__(self):
        return len(self.image_paths)

    def __getitem__(self, idx):
        image_path = self.image_paths[idx]
        image = Image.open(image_path).convert('RGB')  # Convert image to RGB

        if self.transform:
            image = self.transform(image)

        # Assign label based on the directory name
        if "Adposhel" in image_path:
            label = 0
        elif "Agent" in image_path:
            label = 1
        elif "Allaple" in image_path:
            label = 2
        elif "Amonetize" in image_path:
            label = 3
        elif "Androm" in image_path:
            label = 4
        elif "Autorun" in image_path:
            label = 5
        elif "BrowseFox" in image_path:
            label = 6
        elif "Dinwod" in image_path:
            label = 7
        elif "Elex" in image_path:
            label = 8
        elif "Expiro" in image_path:
            label = 9
        elif "Fasong" in image_path:
            label = 10
        elif "HackKMS" in image_path:
            label = 11
        elif "Hlux" in image_path:
            label = 12
        elif "Injector" in image_path:
            label = 13
        elif "InstallCore" in image_path:
            label = 14
        elif "MultiPlug" in image_path:
            label = 15
        elif "Neoreklami" in image_path:
            label = 16
        elif "Neshta" in image_path:
            label = 17
        elif "Other" in image_path:
            label = 18
        elif "Regrun" in image_path:
            label = 19
        elif "Sality" in image_path:
            label = 20
        elif "Snarasite" in image_path:
            label = 21
        elif "Stantinko" in image_path:
            label = 22
        elif "VBA" in image_path:
            label = 23
        elif "VBKrypt" in image_path:
            label = 24
        else:
            label = 25
        return image, label


transform = Compose([
    Resize((224, 224)),
    ToTensor()
])

# Define the dataset
train_dataset = MyDataset(root_dir="D:\\MaleVis_small\\train", transform=transform)
val_dataset = MyDataset(root_dir="D:\\MaleVis_small\\val", transform=transform)


# Define the EfficientNetV2 model
class EfficientNetV2Model(nn.Module):
    def __init__(self, model_name, num_classes=26):  # Update num_classes
        super(EfficientNetV2Model, self).__init__()
        self.efficientnet = timm.create_model(model_name, pretrained=True)
        self.dropout = nn.Dropout(0.5)  # Dropout layer for regularization
        self.fc1 = nn.Linear(1000, 512)  # Additional fully connected layer
        self.fc2 = nn.Linear(512, 128)   # Additional fully connected layer
        self.fc3 = nn.Linear(128, num_classes)     # Output layer

        # Unfreeze half of the parameters
        for idx, param in enumerate(self.efficientnet.parameters()):
            if idx < (len(list(self.efficientnet.parameters())) // 2):
                param.requires_grad = False

    def forward(self, x):
        features = self.efficientnet(x)
        # Additional layers
        x = Func.relu(self.fc1(features))
        x = self.dropout(x)
        x = Func.relu(self.fc2(x))
        x = self.dropout(x)
        output = self.fc3(x)
        return output


# Initialize the model with EfficientNetV2-L
model = EfficientNetV2Model('tf_efficientnetv2_l', num_classes=26)  # Update num_classes

# Define the loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

# Define the data loaders
train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=64, shuffle=False)

# Training loop
for epoch in range(5):
    model.train()
    running_loss = 0.0
    for images, labels in train_loader:
        optimizer.zero_grad()
        outputs = model(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()

    print(f"Epoch {epoch + 1}, Train Loss: {running_loss / len(train_loader)}")

    # Validation loop
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for images, labels in val_loader:
            outputs = model(images)
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    accuracy = 100 * correct / total
    print(f"Epoch {epoch + 1}, Val Accuracy: {accuracy}%")


uploaded = "D:\\Downloads\\malevis_train_val_224x224\\val\\Agent\\eea6bfc12783c2508ca85cd4dee8452bf230ff77resized_image.png"

# Process the uploaded image
img = Image.open(uploaded)
img_tensor = transform(img).unsqueeze(0)  # Add a batch dimension
model.eval()
with torch.no_grad():
    output = model(img_tensor)
    _, predicted = torch.max(output, 1)
    print(f"Predicted class: {predicted.item()}")
    if predicted.item() == 0:
        print("Class A")
    elif predicted.item() == 1:
        print("Class B")
    else:
        print("Class C")