import os
from PIL import Image
import torch
import torch.nn as nn
import torch.nn.functional as Func
from torchvision.transforms import Compose, Resize, ToTensor
from torch.utils.data import Dataset, DataLoader
import timm

def find_max_resolution(root_dir):
    max_width = 0
    max_height = 0

    # Iterate through all images in the dataset
    for subdir, dirs, files in os.walk(root_dir):
        for file in files:
            # Get the path of the current image
            image_path = os.path.join(subdir, file)

            # Open the image
            with Image.open(image_path) as img:
                # Get the pixel size of the image
                width, height = img.size

                # Update max_width and max_height if the current image has higher resolution
                if width > max_width:
                    max_width = width
                if height > max_height:
                    max_height = height

    return max_width, max_height

# Example usage:
root_dir = "D:\\Small dataset\\train"
max_width, max_height = find_max_resolution(root_dir)
print(f"The maximum resolution found in the dataset is {max_width}x{max_height} pixels.")

# Define the dataset class
class MyDataset(Dataset):
    def __init__(self, root_dir, transform=None):
        self.root_dir = root_dir
        self.transform = transform
        self.image_paths = []

        # Iterate through all images in the dataset to find the maximum resolution
        for subdir, dirs, files in os.walk(self.root_dir):
            for file in files:
                image_path = os.path.join(subdir, file)
                self.image_paths.append(image_path)

        self.image_paths = list(set(self.image_paths))  # Remove duplicates

    def __len__(self):
        return len(self.image_paths)

    def __getitem__(self, idx):
        image_path = self.image_paths[idx]
        image = Image.open(image_path).convert('RGB')  # Convert image to RGB

        if self.transform:
            image = self.transform(image)

        # Assign label based on the directory name
        label = 0 if "Allaple.A" in image_path else 1  # Adjust class names accordingly

        return image, label

# Define the transforms
class RescaleToMaxResolution:
    def __init__(self, max_width, max_height):
        self.max_width = max_width
        self.max_height = max_height

    def __call__(self, image):
        width, height = image.size
        aspect_ratio = width / height

        if width > self.max_width or height > self.max_height:
            if aspect_ratio > 1:
                new_width = self.max_width
                new_height = int(self.max_width / aspect_ratio)
            else:
                new_height = self.max_height
                new_width = int(self.max_height * aspect_ratio)
            image = image.resize((new_width, new_height))

        return image
# Define the transforms (including channel conversion)


class GrayscaleToRGB:
    def __init__(self):
        pass  # No parameters needed

    def __call__(self, image):
        # Convert grayscale image to RGB (repeat grayscale channel 3 times)
        return image.convert('RGB')


transform = Compose([
    GrayscaleToRGB(),  # Convert grayscale to RGB
    Resize((max_width, max_height)),
    ToTensor()
])


# Define the dataset
dataset = MyDataset("D:\\Small dataset\\train", transform=transform)
dataset1 = MyDataset("D:\\Small dataset\\test", transform=transform)

# Define the EfficientNetV2 model
class EfficientNetV2Model(nn.Module):
    def __init__(self, model_name):
        super(EfficientNetV2Model, self).__init__()
        self.efficientnet = timm.create_model(model_name, pretrained=True)
        self.dropout = nn.Dropout(0.5)  # Dropout layer for regularization
        self.fc1 = nn.Linear(1000, 512)  # Additional fully connected layer
        self.fc2 = nn.Linear(512, 128)   # Additional fully connected layer
        self.fc3 = nn.Linear(128, 2)     # Output layer

        # Freeze all parameters initially
        for param in self.parameters():
            param.requires_grad = False

    def forward(self, x):
        features = self.efficientnet(x)
        # Additional layers
        x = Func.relu(self.fc1(features))
        x = self.dropout(x)
        x = Func.relu(self.fc2(x))
        x = self.dropout(x)
        output = self.fc3(x)
        return output

# Initialize the model with EfficientNetV2-L
model = EfficientNetV2Model('tf_efficientnetv2_l')

# Define the loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

# Define the data loader
train_loader = DataLoader(dataset, batch_size=32, shuffle=True)
test_loader = DataLoader(dataset1, batch_size=64, shuffle=True)
count = 0

# Training loop
for epoch in range(5):
    model.train()
    running_loss = 0.0
    for images, labels in train_loader:
        optimizer.zero_grad()
        outputs = model(images)
        loss = criterion(outputs, labels)
        # loss.backward()
        optimizer.step()
        running_loss += loss.item()
        count += 1
        print("The count of images is", count)

    print(f"Epoch {epoch + 1}, Loss: {running_loss / len(train_loader)}")
    # Evaluation on test data
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for images, labels in test_loader:
            outputs = model(images)
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    accuracy = 100 * correct / total
    print(f"Epoch {epoch + 1}, Test Accuracy: {accuracy}%")

# Now, let's add code to select an image and make predictions
# from google.colab import files

# Upload an image file
uploaded = "D:\\malimg_dataset\\train\\Allaple.A\\001e981b0162550208406db2ddc2ace3.png"

# Process the uploaded image
img = Image.open(uploaded)
img_tensor = transform(img).unsqueeze(0)  # Add a batch dimension
model.eval()
with torch.no_grad():
    output = model(img_tensor)
    _, predicted = torch.max(output, 1)
    print(f"Predicted class: {predicted.item()}")
    if predicted.item() == 0:
        print("Class A")
    else:
        print("Class B")