import os
from PIL import Image
import torch
import torch.nn as nn
import torch.nn.functional as Func
from torch.utils.data import DataLoader
from torchvision.transforms import Compose, Resize, ToTensor
import timm

# Import libraries for Streamlit
import streamlit as st

# Define the EfficientNetV2 model class (replace with your actual model definition)
class EfficientNetV2Model(nn.Module):
    def __init__(self, model_name, num_classes=26):
        super(EfficientNetV2Model, self).__init__()
        self.efficientnet = timm.create_model(model_name, pretrained=True)
        self.dropout = nn.Dropout(0.5)  # Dropout layer for regularization
        self.fc1 = nn.Linear(1000, 512)  # Additional fully connected layer
        self.fc2 = nn.Linear(512, 128)   # Additional fully connected layer
        self.fc3 = nn.Linear(128, num_classes)     # Output layer

        # Unfreeze half of the parameters
        for idx, param in enumerate(self.efficientnet.parameters()):
            if idx < (len(list(self.efficientnet.parameters())) // 2):
                param.requires_grad = False

    def forward(self, x):
        features = self.efficientnet(x)
        # Additional layers
        x = Func.relu(self.fc1(features))
        x = self.dropout(x)
        x = Func.relu(self.fc2(x))
        x = self.dropout(x)
        output = self.fc3(x)
        return output

# Function to preprocess input images (handle grayscale and RGB)
def preprocess_image(input_image):
    # Open image using PIL Image
    input_image = Image.open(input_image)

    # Convert to RGB if grayscale
    if input_image.mode == 'L':
        input_image = input_image.convert('RGB')

    # Apply transformations
    transform = Compose([
        Resize((224, 224), interpolation=Image.BICUBIC),  # Adjust size if needed
        ToTensor()  # Convert PIL Image to PyTorch tensor
    ])
    input_image_transformed = transform(input_image)

    return input_image_transformed

# Function to predict class from preprocessed image
def predict_class(model, input_image):
    try:
        # Preprocess input image
        input_image_transformed = preprocess_image(input_image)

        # Add batch dimension
        input_image_transformed = input_image_transformed.unsqueeze(0)

        # Perform inference
        with torch.no_grad():
            output = model(input_image_transformed)

        # Get predicted class (index)
        _, predicted_class = torch.max(output, 1)

        # Map class number to class name (assuming you have a list of class names)
        class_names = [
  "Adposhel", "Agent", "Allaple", "Amonetize", "Androm", "Autorun", "BrowseFox",
  "Dinwod", "Elex", "Expiro", "Fasong", "HackKMS", "Hlux", "Injector", "InstallCore",
  "MultiPlug", "Neoreklami", "Neshta", "Benign/Non-Malware", "Regrun", "Sality", "Snarasite",
  "Stantinko", "VBA", "VBKrypt", "Vilsel"
]  # Replace with your actual class names
        predicted_class_name = class_names[predicted_class.item()]

        return predicted_class_name

    except Exception as e:
        return str(e)

# Load the trained model (replace with your model path)
model_path = "C:\\Users\\itsme\\OneDrive\\Desktop\\Model_with_dict (2).pth"  # Update with your model's location
model = EfficientNetV2Model('tf_efficientnetv2_l', num_classes=26)  # Adjust class count
model.load_state_dict(torch.load(model_path, map_location=torch.device('cpu')))
model.eval()  # Set the model to evaluation mode

# Streamlit app
st.title("Malware Classification")

uploaded_file = st.file_uploader("Choose an image...", type=["jpg", "jpeg", "png"])
if uploaded_file is not None:
    st.image(uploaded_file, caption='Uploaded Image.', use_column_width=True)

    if uploaded_file is not None:
        try:
            # Predict the class
            predicted_class = predict_class(model, uploaded_file)
            st.write(f"Predicted Malware Class: {predicted_class}")
        except Exception as e:
            st.error(f"Error: {e}")
